# RAP

This repository contains the code for RAP.
Moreover, it also contains the examples on synthetic as well as real world datasets.

## Directory Structure Summary
```
├── rap.yml                           #Environment file for Anaconda
├── base_code
│   ├── algos
│   │   ├── rap.py                    #base module for RAP
│   │   ├── rap2.py                   #base module for SHAPE
│   │   └── decision.py               #decision phase for AP/RAP/SHAPE. It uses ChainAggregator class from base_code/analysis/overall_clusters module
│   └── analysis
│       ├── overall_clusters.py       #For building global clusters using adjency matrix H
│       ├── metrics_base.py           #For evaluation of clustering results
│       ├── local_info.py             #To plot various scatter plots and histograms
│       └── d3js_export.py            #To export data for web-based visualization
├── examples
│   ├── example.py                    #Basic example. Just Run it and see how it is built
│   ├── real_datasets                 #Real world datasets examples
│   │   ├── analysis.py               #For analysis of real world dataset results contained in this repository
│   │   ├── ap.py                     #To prepare parallel execution of AP
│   │   ├── rap.py                    #To prepare parallel execution of RAP
│   │   ├── exec_base.py              #base module that prepares parallel scripts
│   │   ├── greedy.py                 #To prepare parallel execution of simple greedy approach
│   │   ├── mnist                     
│   │   ├── optdigits
│   │   ├── proteins
│   │   └── threads.py                #Some boilerplate stuff for parallelizing
│   └── synthetic_datasets
│       ├── datasets                  #Contains different synthetic datasets
│       ├── execution_base.py         #Runs the synthetic datasets with given parameters(See file)
│       └── toy_res.eps               #Generated by execution_base.py
├── visualize                         #For web-based view of clustering results
|   ├── d3_v3_min.js                  #D3.js library file
|   ├── graph_functions.js            #Some JS stuff for graph manipulations in web
|   ├── graph.json                    #Generated by base_code/analysis/d3js_export.py. See examples/example.py for more information
|   └── index.html                    
└── README.md
```


## Executing the scripts
The best way to avoid any potential dependency conflicts is to use anacoda environment file
rap.yml. 
To install the environment, simply install anaconda and type:

`conda env create -f rap.yml`

Then, activate the environment using the command:
`source activate rap`

## Adding to python path

You might need to add the path of your project to system path variable.
A simple way to do it can be to paste the follwing lines
on top of the file that you want to run:

```
project_folder = 'RAP'
import os
import re
import sys
MODULE_PATH = re.match("^(.*?){0}".format(project_folder), os.path.realpath(__file__))
sys.path.insert(0, MODULE_PATH.string[:MODULE_PATH.end()])
```
You will need to change the variable `project_folder` if you have changed
its name.



## Things to note:
* The boundary points in density based algos are clustered using KNN with K=5.
* The core is in base_code/algos. 

* base_code/algos/decision.py uses ChainAggregator class from base_code/analysis/overall_clusters module. This module lists three possible methods for finding connected components from of a graph from its __adjacency matrix H__

* base_code/analysis/metrics_base.py is used for evaluation of results. But we can also use more metrics while adhering to the current format.

* examples/example.py is a simple example file where you can see both RAP and SHAPE in action.

* Synthetic datasets are run by execution_base. It generates the figure toy_res.eps

* To verify results for real datasets, just run the file analysis.py. Select the __DIR__ varaible oappropriately to see results of MNIST, OPTDIGITS and Proteins datasets.

* To run real world datasets for yourself, you will need to go to the directory of required dataset and then run __exec.py__
